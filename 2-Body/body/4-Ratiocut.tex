\cleardoublepage

\chapter{面向链下存储的自适应聚合机制}
\label{sec:packaging}
本文的测量结果揭示了一个关键问题：不当的数据聚合策略会导致查询过程中需要跨越更多存储单元，进而增加了网络传输的延迟。
在本章中，本文提出了一种自适应UWG的方法，它能够根据数据所有者的历史查询模式精确捕捉用户的查询行为。
利用这个自适应UWG，本文将数据分批的问题转化为一个聚类问题，即根据用户的查询需求将海量原始数据划分成多个有意义的聚类。

\section{基于历史查询的自适应图构建过程}
\label{sec:UWG}

\begin{table}
    \centering
    \caption{TimeChain关于自适应聚合的符号和定义}
    \begin{tabular}{|c|c|}
        \hline
        \textbf{符号} & \textbf{描述} \\
        \hline
        $d_i$   & 第$i$个设备 \\
        \hline
        $D$     & 所有设备集合，$D = \{d_0, ..., d_n\}$\\
        \hline
        $s_i$   & 物联网传感器产生的第$i$条数据 \\
        \hline
        $S$     & 所有数据集合，$S = \{s_0, ..., s_m \}$\\
        \hline
        $Q^i$   & 第$i$条用户查询集合，$Q^i = \{ q_0, ..., q_r \}$\\
        \hline
        $q_k$   & $k$中的第$Q^i$条查询 \\
        \hline
        $l_{ab}$& 查询权重包含设备$a$和设备$b$ \\
        \hline
        $L$     & 一起查询的数据权重，$L = \{l_{ab} | \exists_{a,b} \in D \}$\\
        \hline
        $x^k_{ab}$ & 设备$a$和设备$b$是否同时被查询 \\
        \hline
        $X^k$   & 设备访问信息，$X^k = \{x^k_{ab} | \exists_{a,b} \in D \}$\\
        \hline
        $P$     & 数据打包结果，$P = \{ \{ s_i, ... \}, ... \}$\\
        \hline
    \end{tabular}
    \label{tab:notations}
\end{table}

由于物联网的原始数据是孤立的点，本文在数据点之间创建加权边，表示被联合查询的概率。
数据点$a$和$b$之间的边的权重$l_{ab}$表示为：

\begin{equation} 
    \label{eq:weight}
    \begin{split}
        l_{ab} =
        \begin{cases}
            \sqrt{ (id_a - id_b)^2 + (t_a - t_b)^2 } &, k = 0 \\  
            \theta \cdot l_{ab} + (1 - \theta) \cdot x_{ab}^k &, k \geq 1  
        \end{cases}
    \end{split}
\end{equation}

其中$l_{ab}$被初始化为两个数据点设备ID和数据到达时间之间的欧氏距离。
当用户的请求到达时，UWG会根据请求中涉及的数据查询范围进行动态调整。
为了避免查询图的过度存储开销，本文在更新图时忽略了数据的时间维度，只考虑数据的设备ID维度。

本文使用变量$x_{ab}^k$来指示第$k$个查询的内容。
当第k个查询包含设备$d_a$和设备$d_b$时，$x_{ab}^k=1$，否则$x_{ab}^k=0$。
然后，距离$l_{ab}$将根据$x_{ab}^k$进行更新。

由于用户请求可能非常随机，因此图的更新和变化可能会非常频繁。
因此，本文设置了一个影响因子$\theta$来确定用户请求对图更新的影响。
当$\theta$接近1时，权重受查询的影响更大。
当$\theta$接近0时，这意味着图尽可能保持初始状态。

同时，TimeChain使用滑动窗口动态更新UWG，尽可能避免单个查询的对系统的鲁棒性影响。
虽然查询模式的突然变化最初会降低打包准确率，但系统会在多次查询后快速适应。
通过自适应权重聚类算法，本文可以根据节点之间的距离和查询的相关性动态调整节点之间的权重，以更好地反映它们的相似性。
这有助于在打包过程中更准确地确定哪些节点的数据应放置在同一批中，以提高查询的效率和准确性。

\section{基于谱聚类算法的封装机制}
\label{sec:ratiocut}

\subsection{聚类算法选择}
通过建立自适应的UWG，本文将数据分批的问题转化为聚类问题。
本文综合考虑了目前的几类聚类算法：基于划分的算法、基于模型的方法以及基于图论的方法。

\textbf{基于划分的算法。}
基于划分的算法通过迭代优化过程，将数据集划分为预定义数量的簇。
这类算法中最著名的是K-means~\cite{kanungo2002efficient}。
K-means算法首先随机选择$k$个点作为初始质心，然后将每个数据点分配给最近的质心所在的簇，并重新计算每个簇的质心。
这个过程不断重复，直到质心不再显著变化或达到最大迭代次数。
尽管这种方法简单直观且计算效率较高，但它对簇的数量$k$非常敏感，初始质心的选择也会影响最终结果。
此外，K-means假设簇是球形分布的，难以处理非球形簇或复杂形状的数据。
因此，对于TimeChain输入的时间序列数据，这些算法可能无法有效捕捉数据的真实分布，导致聚类效果不佳。

\textbf{基于模型的方法。}
基于模型的方法通过假设数据是由特定的概率分布生成的，并使用统计模型进行参数估计来实现聚类。
最典型的方法，例如高斯混合模型~\cite{kanungo2002efficient}（Gaussian Mixture Models, GMM），通过迭代地更新每个数据点属于各个高斯分布的概率，以及各个高斯分布的均值、协方差矩阵等参数，逐步优化模型，直到收敛。
虽然GMM能够提供概率解释并适用于特定类型的分布，但其计算复杂度较高，特别是在处理大规模数据集时，需要大量的计算资源和时间。
对于物联网设备来说，由于资源受限（如内存、CPU性能），这种复杂的计算对于弱性能设备而言难以承受，从而影响系统的实时性和响应速度。
另一种基于模型的方法是隐马尔可夫模型~\cite{he2010laplacian}（Hidden Markov Model, HMM），假设数据是由隐藏状态序列生成的，通过训练HMM模型，可以发现隐藏状态的转换模式，从而实现聚类。
然而，HMM的训练过程同样涉及复杂的概率计算，特别是当状态空间较大时，计算复杂度会显著增加。
因此，尽管这些方法在某些场景下非常有效，但在TimeChain的应用中并不理想，因为它们不适合资源受限的物联网环境。

\textbf{基于图论的方法。}
基于图论的方法，特别是谱聚类~\cite{von2007tutorial}（Spectral Clustering），利用图的拉普拉斯矩阵的特征向量来进行聚类，非常适合处理复杂的簇结构。
谱聚类的基本思想是将数据点表示为图中的顶点，顶点之间的边权重表示数据点之间的相似性或距离。
具体来说，首先根据数据点之间的相似性或距离度量构建一个加权图，其中每个节点代表一个数据点，边的权重表示节点之间的相似性。
接下来，从相似性图中计算出图的拉普拉斯矩阵。
拉普拉斯矩阵是一种特殊的矩阵，反映了图的拓扑结构和节点之间的关系。
随后，对拉普拉斯矩阵进行特征分解，提取前几个最小的非零特征值对应的特征向量。
这些特征向量捕获了图的主要结构信息。
最后，将提取的特征向量作为新的低维表示，应用传统的聚类算法（如K-means）进行聚类。
谱聚类不仅能够发现任意形状的簇，而且相对GMM和HMM而言，其计算复杂度是可以接受的，特别适合处理大规模数据集。
此外，谱聚类在处理噪声数据和不规则形状的簇方面表现优异。
因此，TimeChain选择了谱聚类算法进行聚类分析，以高效地处理物联网时序数据，并确保在资源受限的环境中也能保持良好的性能。

\subsection{数据封装过程}

\begin{algorithm}[t]
	\caption{聚合算法}
	\label{algo:package}
	\LinesNumbered
	\KwIn{ 输入设备集$D$，数据集$S$，用户的历史查询集$Q^i$ }
	\KwOut{ 最优聚合结果$P$ }
	$S' \gets \{s^a | a \in D \And s^a \subset S\}$ //根据设备ID梳理原始数据 \;
	$L \gets \Big\{ \sqrt{ (id_a - id_b)^2 + (t_a - t_b)^2 } \Big| \exists_{a,b \in D} \Big\}$ //根据\autoref{eq:weight}初始化权重集$L$ \;
	$X \gets \{0 | \exists_{a,b \in D} \}$ \;
	\For{$q^k \in Q^{i}$}{
		\If{$a,b \in q^k$}{
			\textnormal{使用$x^k_{ab} \gets 1 $更新$X$} //将用户查询请求信息$Q^{i-1}$打包成集合$X^k$\;
		}
	}
	$L \gets \Big\{ \theta \cdot l_{ab} + (1 - \theta) \cdot x_{ab}^k \Big| \exists_{a,b \in D} \exists_{l_{ab} \in L} \Big\}$ //更新UWG的权重集$L$ \;
	$D' \gets \textit{cluster}(D, L)$ //使用谱聚类算法获得聚合结果$D'$ \;
	$P \gets \{\}$ //初始化聚合结果$P$ \;
	\For{$d^j \in D'$}{
		\textnormal{增加$\{ s^a | \exists_{a \in d^j} \}$到$P$中} //将设备数据合并到$P$中 \;
	}
	\textbf{return} $P$\;
\end{algorithm}

% \begin{algorithm}[t]
% 	\caption{聚合算法}
% 	\label{algo:package}
%     \begin{algorithmic}[1]
%         \REQUIRE 输入设备集$D$，数据集$S$，用户的历史查询集$Q^i$
%         \ENSURE 最优聚合结果$P$
%         \STATE $S' \gets \{s^a | a \in D \And s^a \subset S\}$ //根据设备ID梳理原始数据
%         \STATE $L \gets \Big\{ \sqrt{ (id_a - id_b)^2 + (t_a - t_b)^2 } \Big| \exists_{a,b \in D} \Big\}$ //根据\autoref{eq:weight}初始化权重集$L$
%         \STATE $X \gets \{0 | \exists_{a,b \in D} \}$ 
%         \FOR{$q^k \in Q^{i}$}
%             \IF{$a,b \in q^k$}
%                 \STATE \textnormal{使用$x^k_{ab} \gets 1 $更新$X$} //将用户查询请求信息$Q^{i-1}$打包成集合$X^k$
%             \ENDIF
%         \ENDFOR
%         \STATE $L \gets \Big\{ \theta \cdot l_{ab} + (1 - \theta) \cdot x_{ab}^k \Big| \exists_{a,b \in D} \exists_{l_{ab} \in L} \Big\}$ //更新UWG的权重集$L$
%         \STATE $D' \gets \textit{cluster}(D, L)$ //使用谱聚类算法获得聚合结果$D'$
%         \STATE $P \gets \{\}$ //初始化聚合结果$P$
%         \FOR{$d^j \in D'$}
%             \STATE \textnormal{增加$\{ s^a | \exists_{a \in d^j} \}$到$P$中} //将设备数据合并到$P$中
%         \ENDFOR
%         \STATE \textbf{return} $P$
%     \end{algorithmic}
% \end{algorithm}

\autoref{algo:package}显示TimeChain的整个打包过程。
该算法的输入包括输入设备集$D$、数据集$S$和用户的历史查询集$Q^i$。
为了高效处理数据，TimeChain在预处理阶段对数据集$S'$进行组织，将具有相同设备ID的数据点归入一个单位时间窗口长度对应的集合中（第1行）。
这一操作忽略了时间维度，旨在简化数据结构，便于后续处理。
TimeChain根据\autoref{eq:weight}计算每个点之间的权重$l$，并将权重组合成权重集$L$（第2行）。
权重$l$的初始值基于设备ID和数据到达时间的欧氏距离，用于衡量数据点之间的相似性。
对于上一个滑动窗口中的历史查询记录集合$Q^{i-1}$，TimeChain根据每个查询涉及的具体数据点整合查询特征集合$X$（第4-8行）。
具体而言，对于第$k$次查询$q^k$，如果查询中包含设备$a$和设备$b$时，$x^k_{ab}$被设置为1。
否则，$x^k_{ab}$被设置为0。
这一过程获取了用户的查询模式，为后续的权重更新提供依据。
然后，本文根据收集到的查询信息$X$，根据$l_{ab} = \theta \cdot l_{ab} + (1 - \theta) \cdot x_{ab}^k$更新权重集$L$（第9行）。
通过这种方式，TimeChain动态调整数据点之间的权重，以更好地反映它们的查询相关性。
对于更新后的权重集$L$，TimeChain可以构建出迭代后的UWG$(D,L)$，图中的节点表示设备数据点，边长为数据点之间的查询权重。
对于UWG$(D,L)$，根据之前的分析，TimeChain使用谱聚类算法来获得聚合结果$D'$（第10行）。
谱聚类算法能够处理复杂的簇结构，特别适合处理物联网数据的不规则分布。
$D'$中被聚合在一起的点表示经常被一起查询的数据点。
根据聚合结果$D'$，本文将数据整合到$P$中，这是本文得到的聚合结果（第12-14行）。

\section{本章小结}
本章深入研究了面向链下存储的自适应聚合机制，旨在解决物联网时序数据存储中的查询延迟问题。
本章发现，不当的数据聚合策略会导致查询过程中需要跨越更多存储单元，从而增加了网络传输的延迟。
为此，本章提出了一种基于历史查询的自适应无向加权图（UWG）方法，该方法能够精确捕捉用户的查询行为，并根据这些行为将数据分批处理，以优化查询效率。
对于根据用户查询特征生成的图，本章综合分析了目前的聚类算法，针对当前问题的特点提出了一种基于谱聚类算法的封装机制，以更好地处理不规则形状的数据聚类问题。
通过这种方法，本章可以更准确地确定哪些节点的数据应放置在同一批中，以提高查询的效率和准确性。
